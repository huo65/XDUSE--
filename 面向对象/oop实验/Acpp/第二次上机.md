# 第二次上机

## 要求：


在完成第一次上机内容的基础上，修改乘客乘梯请求规则：

（1） 随机产生每位乘客初次所要到达的楼层，并随机选择一部电梯让其等待；

（2） 每位乘客乘坐电梯达到指定楼层后，随机地停留10-120秒后，再随机地去往另一楼层，依此类推。当每位乘客乘坐过L次（每人的L值不同，在产生乘客时随机地在1-10之间确定）电梯后，第L+1次为下至底层并结束乘梯行为。到所有乘客结束乘梯行为时，本次仿真结束。



## 修改说明

第二次相对第一次难度实现了很大的跨越，在尝试过n次修该后决定重构整个项目。

### 中断机制的不可行性分析

在第一次我使用了类似于操作系统中断机制的思想

```c++
      while (1)
        {
            for (int i = 0; i < NUM_PEOPLE; i++)
            {
				//遍历乘客的行动时间，只要到达相应时间代表产生中断
                if (timer == passengers[i+1].getArriveTime())
                {
                    fault =1;
                    ……
                }
            }
      if (fault)elevators[elevatorId].dispatch(floors, passengers);//然后根据有无事件发生做出处理
            fault =0;

            timer++;
      }
```

这样的方式极大的提高了程序的效率，在不需要处理事件的时候不浪费额外的资源

可惜这个思路对于第二次要求捉襟见肘，因为乘客的乘坐次数增加就会导致事件随时间随机的产生，在处理一个请求的时间内总会有意想不到的请求发生。

> 例如当电梯向上时经过一层楼的时间段内刚好有人也要上楼，在现有的架构下难以处理类似的事件

考虑过在乘客类和电梯类中间加一层中介，用类似消息队列的思想处理请求，但效果仍不理想，每次电梯调度的工作量还是很大。

所以说中断机制是不可行性，就算最终考虑并解决所有的情况，最后系统的复杂度并不亚于暴力遍历解决问题。

# 最终设计

在每一个时间单位都会有意想不到的事件发生的背景下，系统只能时刻去监听并处理请求。

- building.cpp //统一管理电梯和乘客，因为每一个时间单位都要去有处理将其对应的行为封装起来方便处理
  - building.h
- Elevator.cpp//电梯类，活动改变为状态驱动
  - Elevator.h
- Passenger.cpp//乘客类，同电梯类
  - Passenger.h
- global.cpp//全局变量类，用于管理全局共享的变量
  - global.h
- main.cpp//主类，控制执行

##### 状态驱动：即电梯或者乘客的行为是严格根据其在这一时刻的状态决定的

![image-20230522223716597](C:/Users/86132/AppData/Roaming/Typora/typora-user-images/image-20230522223716597.png)

这样的话就实现了整个系统可以应对可能面临的所有“意想不到”的情况，因为全部对象的行为都是实时更新，时刻做出响应的。

#### 核心代码

对于本次的特殊要求，由下面的代码完成：

```c++
 case  TAKE:
            NowFloor = e[which]->NowFloor;        //更新当前乘坐电梯的楼层
            //当前状态为乘坐，则查看是否到达目的楼层 ，将状态置为 “离开”或“停止”
            if (NowFloor == NextFloor)
            {
                times--;//到达一个目的地后将乘梯次数-1，并做出判断
                switch (times)
                {
                    case 0://完成所有乘梯活动
                        status = OVER;
                        break;
                    case 1://最后一次回到一楼
                        status = LEAVE;
                        NextFloor = 1;
                        NextTime = (nowtime + 10);
                        break;
                    default:
                        status = LEAVE;
                        //设定新的目标楼层
                        int temp = ((rand() % NUM_FLOORS-1)+1);
                        while (temp == NowFloor)    //如果取出的数是当前楼层，则重新取随机数，直到不同
                        {
                            temp = ((rand() % NUM_FLOORS-1)+1);
                        }
                        NextFloor = temp;
                        NextTime = (nowtime + ((rand() % 111) + 10));     //生成下一次乘梯时间,随机停留10-120秒
                        break;
                }
                e[which]->people--;

            }
            break;
```

